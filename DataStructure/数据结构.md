以下大部分内容来自极客时间课程[《数据结构与算法之美》](http://gk.link/a/10jwX)

10 个数据结构：
  - 数组
  - 链表
  - 栈
  - 队列
  - 散列表
  - 二叉树
  - 堆
  - 跳表
  - 图
  - Trie 树


### 1.  线性表与非线性表
线性表 `(Linear list)` 就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。其实除了数组，链表、队列、栈等也是线性表结构。
![线性表](https://raw.githubusercontent.com/wubuwei/backend_image/master/%E7%BA%BF%E6%80%A7%E8%A1%A8.png)

非线性表中，数据之间并不是简单的前后关系。比如二叉树、堆、图等。
![非线性表](https://raw.githubusercontent.com/wubuwei/backend_image/master/%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A1%A8.png)


### 2. 数组（Array）

#### 1）什么是数组
数组是一种线性表数据结构。它用一组 `连续` 的 `内存空间`，来存储一组具有相同类型的数据。

#### 2）数组复杂度
- 排好序的数组，用二分查找，时间复杂度是 `O(logn)`
- 数组支持随机访问，根据下标随机访问的时间复杂度为 `O(1)`
- 数组插入、删除，时间复杂度，最好情况 `O(1)`，最坏情况 `O(n)`

#### 3）数组实现LRU缓存淘汰策略
方式一：首位置保存最新访问数据，末尾位置优先清理
当访问的数据未存在于缓存的数组中时，直接将数据插入数组第一个元素位置，此时数组所有元素需要向后移动1个位置，时间复杂度为O(n)；当访问的数据存在于缓存的数组中时，查找到数据并将其插入数组的第一个位置，此时亦需移动数组元素，时间复杂度为O(n)。缓存用满时，则清理掉末尾的数据，时间复杂度为O(1)。

方式二：首位置优先清理，末尾位置保存最新访问数据
当访问的数据未存在于缓存的数组中时，直接将数据添加进数组作为当前只有一个元素时间复杂度为O(1)；当访问的数据存在于缓存的数组中时，查找到数据并将其插入当前数组最后一个元素的位置，此时亦需移动数组元素，时间复杂度为O(n)。缓存用满时，则清理掉数组首位置的元素，且剩余数组元素需整体前移一位，时间复杂度为O(n)。（优化：清理的时候可以考虑一次性清理一定数量，从而降低清理次数，提高性能。）


### 3. 链表（Linked list）

#### 1）什么是缓存
缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非广泛的应用，比如常见的CPU缓存、数据库缓存、浏览器缓存等等。

#### 2）为什么使用缓存，即缓存的特点
缓存的大小是有限的，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？就需要用到缓存淘汰策略。

#### 3）什么是缓存淘汰策略
指的是当缓存被用满时清理数据的优先顺序。

#### 4）常见的缓存淘汰策略：
- 先进先出策略 FIFO(First In,First Out)
- 最少使用策略 LFU(Least Frequently Used)
- 最近最少使用使用策略 LRU(Least Recently Used)

#### 5）链表实现LRU缓存淘汰策略
当访问的数据没有存储在缓存的链表中时，直接将数据插入链表表头，时间复杂度为 `O(1)`；当访问的数据存在于存储的链表中时，将该数据对应的节点，插入到链表表头,时间复杂度为 `O(n)`。如果缓存被占满，则从链表尾部的数据开始清理，时间复杂度为 `O(1)`。

#### 6）缓存设计思想
`缓存` 实际上就是利用了 `空间换时间` 的设计思想。如果我们把数据存储在硬盘上，会比较节省内存，但每次查找数据都要询问一次硬盘，会比较慢。但如果我们通过缓存技术，事先将数据加载在内存中，虽然会比较耗费内存空间，但是每次数据查询的速度就大大提高了。
对于执行较慢的程序，可以通过消耗更多的内存 `（空间换时间）` 来进行优化；而消耗过多内存的程序，可以通过消耗更多的时间 `（时间换空间）` 来降低内存的消耗。

#### 7）链表特点
链表不需要连续的内存空间，它通过 `“指针”` 将一组 `零散` 的内存块 `串联` 起来使用。

把内存块称为链表的“结点”，把内存块称为链表的“结点”，把最后一个结点叫作尾结点。

- 单链表
单链表头结点用来记录链表的基地址。有了它，我们就可以遍历得到整条链表。而尾结点特殊的地方是：指针不是指向下一个结点，而是指向一个空地址 `NULL`，表示这是链表上最后一个结点。

- 循环链表
循环链表是一种特殊的单链表。循环链表的尾结点指针是指向链表的头结点。

- 双向链表
双向链表，顾名思义，它支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。
双向链表可以支持 O(1) 时间复杂度的情况下找到前驱结点，正是这样的特点，也使双向链表在某些情况下的插入、删除等操作都要比单链表简单、高效。
