以下大部分内容来自极客时间课程[《数据结构与算法之美》](http://gk.link/a/10jwX)

10 个数据结构：
  - 数组
  - 链表
  - 栈
  - 队列
  - 散列表
  - 二叉树
  - 堆
  - 跳表
  - 图
  - Trie 树


## 1. 线性表与非线性表

线性表 `(Linear list)` 就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。其实除了数组，链表、队列、栈等也是线性表结构。

![线性表](https://raw.githubusercontent.com/wubuwei/backend_image/master/%E7%BA%BF%E6%80%A7%E8%A1%A8.png)

非线性表中，数据之间并不是简单的前后关系。比如二叉树、堆、图等。
![非线性表](https://raw.githubusercontent.com/wubuwei/backend_image/master/%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A1%A8.png)


## 2. 数组（Array）

### 1）什么是数组
数组是一种线性表数据结构。它用一组 `连续` 的 `内存空间`，来存储一组具有相同类型的数据。

### 2）数组复杂度
- 排好序的数组，用二分查找，时间复杂度是 `O(logn)`
- 数组支持随机访问，根据下标随机访问的时间复杂度为 `O(1)`
- 数组插入、删除，时间复杂度，最好情况 `O(1)`，最坏情况 `O(n)`

### 3）数组实现LRU缓存淘汰策略
- 方式一：首位置保存最新访问数据，末尾位置优先清理

当访问的数据未存在于缓存的数组中时，直接将数据插入数组第一个元素位置，此时数组所有元素需要向后移动 `1` 个位置，时间复杂度为 `O(n)`；当访问的数据存在于缓存的数组中时，查找到数据并将其插入数组的第一个位置，此时亦需移动数组元素，时间复杂度为 `O(n)`。缓存用满时，则清理掉末尾的数据，时间复杂度为 `O(1)`。

- 方式二：首位置优先清理，末尾位置保存最新访问数据

当访问的数据未存在于缓存的数组中时，直接将数据添加进数组作为当前只有一个元素时间复杂度为 `O(1)`；当访问的数据存在于缓存的数组中时，查找到数据并将其插入当前数组最后一个元素的位置，此时亦需移动数组元素，时间复杂度为 `O(n)`。缓存用满时，则清理掉数组首位置的元素，且剩余数组元素需整体前移一位，时间复杂度为 `O(n)`。（优化：清理的时候可以考虑一次性清理一定数量，从而降低清理次数，提高性能。）


## 3. 链表（Linked list）

### 1）什么是缓存
缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非广泛的应用，比如常见的CPU缓存、数据库缓存、浏览器缓存等等。

### 2）为什么使用缓存，即缓存的特点
缓存的大小是有限的，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？就需要用到缓存淘汰策略。

### 3）什么是缓存淘汰策略
指的是当缓存被用满时清理数据的优先顺序。

### 4）常见的缓存淘汰策略：
- 先进先出策略 FIFO(First In,First Out)
- 最少使用策略 LFU(Least Frequently Used)
- 最近最少使用策略 LRU(Least Recently Used)

### 5）链表实现LRU缓存淘汰策略
当访问的数据没有存储在缓存的链表中时，直接将数据插入链表表头，时间复杂度为 `O(1)`；当访问的数据存在于存储的链表中时，将该数据对应的节点，插入到链表表头，时间复杂度为 `O(n)`。如果缓存被占满，则从链表尾部的数据开始清理，时间复杂度为 `O(1)`。

### 6）缓存设计思想
`缓存` 实际上就是利用了 `空间换时间` 的设计思想。如果我们把数据存储在硬盘上，会比较节省内存，但每次查找数据都要询问一次硬盘，会比较慢。但如果我们通过缓存技术，事先将数据加载在内存中，虽然会比较耗费内存空间，但是每次数据查询的速度就大大提高了。
对于执行较慢的程序，可以通过消耗更多的内存 `（空间换时间）` 来进行优化；而消耗过多内存的程序，可以通过消耗更多的时间 `（时间换空间）` 来降低内存的消耗。

### 7）链表特点
链表不需要连续的内存空间，它通过 `“指针”` 将一组 `零散` 的内存块 `串联` 起来使用。

把内存块称为链表的“结点”，把内存块称为链表的“结点”，把最后一个结点叫作尾结点。

- 单链表
单链表头结点用来记录链表的基地址。有了它，我们就可以遍历得到整条链表。而尾结点特殊的地方是：指针不是指向下一个结点，而是指向一个空地址 `NULL`，表示这是链表上最后一个结点。

- 循环链表
循环链表是一种特殊的单链表。循环链表的尾结点指针是指向链表的头结点。

- 双向链表
双向链表，顾名思义，它支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。
双向链表可以支持 O(1) 时间复杂度的情况下找到前驱结点，正是这样的特点，也使双向链表在某些情况下的插入、删除等操作都要比单链表简单、高效。

## 4. 栈（Stack）

后进者先出，先进者后出，这就是典型的“栈”结构。

栈只支持两个基本操作：`入栈 push` 和 `出栈 pop`

栈是一种“操作受限”的线性表，只允许在一端插入和删除数据。

从功能上来说，数组或链表确实可以替代栈，但你要知道，特定的数据结构是对特定场景的抽象，而且，数组或链表暴露了太多的操作接口，操作上的确灵活自由，但使用时就比较不可控，自然也就更容易出错。

但当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，我们就应该首选“栈”这种数据结构。

栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈，我们叫作顺序栈，用链表实现的栈，我们叫作链式栈。

不管基于数组还是链表，入栈、出栈的时间复杂度都为 `O(1)`。

数组实现栈自动扩容时，个别情况是 `O(n)` 级别复杂度，比如自动扩容时，会进行完整数据的拷贝。

#### 为什么函数调用要用“栈”来保存临时变量呢？用其他数据结构不行吗？

其实，我们不一定非要用栈来保存临时变量，只不过如果这个函数调用符合后进先出的特性，用栈这种数据结构来实现，是最顺理成章的选择。

从调用函数进入被调用函数，对于数据来说，变化的是什么呢？是作用域。所以根本上，只要能保证每进入一个新的函数，都是一个新的作用域就可以。而要实现这个，用栈就非常方便。在进入被调用函数的时候，分配一段栈空间给这个函数的变量，在函数结束的时候，将栈顶复位，正好回到调用函数的作用域内。

#### 内存中的堆栈和数据结构堆栈不是一个概念

内存中的堆栈是真实存在的物理区，数据结构中的堆栈是抽象的数据存储结构。

内存空间在逻辑上分为三部分：代码区、静态数据区和动态数据区，动态数据区又分为栈区和堆区。

- 代码区：存储方法体的二进制代码。高级调度（作业调度）、中级调度（内存调度）、低级调度（进程调度）控制代码区执行代码的切换。
- 静态数据区：存储全局变量、静态变量、常量。系统自动分配和回收。
- 动态数据区
  - 栈区：存储运行方法的形参、局部变量、返回值。由系统自动分配和回收。
  - 堆区：`new` 一个对象的引用或地址存储在栈区，指向该对象存储在堆区中的真实数据。


## 5. 队列（Queue）

先进者先出，这就是典型的“队列”。

队列两个最基本的操作：`入队 enqueue` 和 `出队 dequeue`

队列跟栈一样，也是一种操作受限的线性表数据结构。

### 数序队列和链式队列
用数组实现的队列叫作顺序队列，用链表实现的队列叫作链式队列。

入队、出队的时间复杂度都为 `O(1)`。当数序队列数据搬移情况出现时，时间复杂度为 `O(n)`。

### 循环队列
循环队列，原本数组是有头有尾的，是一条直线。把首尾相连，扳成了一个环。

在数组实现队列的时候，会有数据搬移操作，要想解决数据搬移的问题，需要像环一样的循环队列。

要想写出没有 bug 的循环队列的实现代码，最关键的是，确定好队空和队满的判定条件。
- 队列为空的判断条件仍然是 `head == tail`。
- 当队满时，`(tail+1)%n=head`。 `tail` 指向的位置实际上是没有存储数据的。所以，循环队列会浪费一个数组的存储空间。

### 阻塞队列

- 阻塞队列就是入队、出队操作可以阻塞。
- 在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。
- 基于阻塞队列实现的“生产者 - 消费者模型”，可以有效地协调生产和消费的速度。

### 并发队列

- 并发队列就是队列的操作多线程安全。
- 最简单直接的实现方式是直接在 `enqueue()、dequeue()` 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。
- 实际上，基于数组的循环队列，利用 `CAS` 原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。

## 6. 散列表
