## 1. MySQL 逻辑架构

![MySQL 逻辑架构图](https://raw.githubusercontent.com/wubuwei/backend_image/master/MySQL%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84%E5%9B%BE.png)

大体来说，`MySQL` 可以分为 `Server 层`和 `存储引擎层` 两部分。

- `Server 层` 包括 `连接器`、`查询缓存`、`分析器`、`优化器`、`执行器` 等，涵盖 `MySQL` 的大多数核心服务功能，以及所有的 `内置函数（如日期、时间、数学和加密函数等）`，所有跨存储引擎的功能都在这一层实现，比如 `存储过程`、`触发器`、`视图` 等。

- `存储引擎层` 负责数据的存储和提取。其架构模式是插件式的，支持 `InnoDB`、`MyISAM`、`Memory` 等多个存储引擎。现在最常用的存储引擎是 `InnoDB`，它从 `MySQL 5.5.5` 版本开始成为了默认存储引擎。


### 连接器

数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。

问题：

有时候 `MySQL` 占用内存涨得特别快，这是因为 `MySQL` 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（`OOM`:`Out Of Memory`），从现象看就是 `MySQL` 异常重启了。

解决方式：

1. 定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。
2. 如果你用的是 `MySQL 5.7` 或更新版本，可以在每次执行一个比较大的操作后，通过执行 `mysql_reset_connection` 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。

### 查询缓存

查询缓存往往弊大于利。

查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。

`MySQL 8.0` 版本直接将查询缓存的整块功能删掉了，也就是说 `8.0` 开始彻底没有这个功能了。


### 分析器

分析器先会做 `词法分析` 识别 `select` 等关键词，再做 `语法分析` 判断是否符合 `MySQL` 语法。

分析器还会进行语义分析，比如查询未知列的错误是出现在这里


### 优化器

优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（`join`）的时候，决定各个表的连接顺序。

### 执行器

`MySQL` 通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。

数据库的慢查询日志中看到一个 `rows_examined` 的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。

在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟 `rows_examined` 并不是完全相同的。


## 2. MySQL 日志系统

与查询流程不一样的是，更新流程还涉及两个重要的日志模块：`redo log（重做日志）` 和 `binlog（归档日志）`


### redo log

`redo log` 是 `InnoDB` 引擎特有的日志。

`WAL` 技术的全称是 `Write-Ahead Logging`，它的关键点就是先写日志，再写磁盘

当有一条记录需要更新的时候，`InnoDB` 引擎就会先把记录写到 `redo log` 里面，并更新内存，这个时候更新就算完成了。同时，`InnoDB` 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。

有了 `redo log`，`InnoDB` 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 `crash-safe`。

`innodb_flush_log_at_trx_commit` 这个参数设置成 `1` 的时候，表示每次事务的 `redo log` 都直接持久化到磁盘。可以保证 `MySQL` 异常重启之后数据不丢失。

### binlog

`MySQL` 的 `Server` 层日志，称为 `binlog`。

为什么有两份日志系统？因为最开始 `MySQL` 里并没有 `InnoDB` 引擎。`MySQL` 自带的引擎是 `MyISAM`，但是 `MyISAM` 没有 `crash-safe` 的能力，`binlog` 日志只能用于归档。而 `InnoDB` 是另一个公司以插件形式引入 `MySQL` 的，既然只依靠 `binlog` 是没有 `crash-safe` 能力的，所以 `InnoDB` 使用另外一套日志系统——也就是 `redo log` 来实现 `crash-safe` 能力。

`sync_binlog` 这个参数设置成 `1` 的时候，表示每次事务的 `binlog` 都持久化到磁盘。可以保证 MySQL 异常重启之后 `binlog` 不丢失。


### redo log 与 binlog 对比不同

1. `redo log` 是 `InnoDB` 引擎特有的；`binlog` 是 `MySQL` 的 `Server` 层实现的，所有引擎都可以使用。
2. `redo log` 是物理日志，记录的是“在某个数据页上做了什么修改”；`binlog` 是逻辑日志，记录的是这个语句的原始逻辑，比如“`给 ID=2 这一行的 c 字段加 1 `”。
3. `redo log` 是循环写的，空间固定会用完；`binlog` 是可以追加写入的。“追加写”是指 `binlog` 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。


逻辑日志可以给别的数据库，别的引擎使用，已经大家都讲得通这个“逻辑”；
物理日志就只有“我”自己能用，别人没有共享我的“物理格式”

### update 语句时的内部流程
1. 执行器先找引擎取 `ID=2` 这一行。`ID` 是主键，引擎直接用树搜索找到这一行。如果` ID=2` 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。
2. 执行器拿到引擎给的行数据，把这个值加上 `1`，比如原来是 `N`，现在就是 `N+1`，得到新的一行数据，再调用引擎接口写入这行新数据。
3. 引擎将这行新数据更新到内存中，同时将这个更新操作记录到 `redo log` 里面，此时 `redo log` 处于 `prepare` 状态。然后告知执行器执行完成了，随时可以提交事务。
4. 执行器生成这个操作的 `binlog`，并把 `binlog` 写入磁盘。
5. 执行器调用引擎的提交事务接口，引擎把刚刚写入的 `redo log` 改成提交（`commit`）状态，更新完成。

### 一天一备跟一周一备的对比

好处是“最长恢复时间”更短。

在一天一备的模式里，最坏情况下需要应用一天的 `binlog`。比如，你每天 `0` 点做一次全量备份，而要恢复出一个到昨天晚上 `23` 点的备份。

一周一备最坏情况就要应用一周的 `binlog` 了。

恢复目标时间 `RTO(Recovery Time Objective)`
当然这个是有成本的，因为更频繁全量备份需要消耗更多存储空间，所以这个 `RTO` 是成本换来的，就需要你根据业务重要性来评估了。

## 3. 事务隔离

`事务` 就是要保证一组数据库操作，要么全部成功，要么全部失败。在 `MySQL` 中，事务支持是在引擎层实现的。`MySQL `原生的 `MyISAM` 引擎就不支持事务，这也是 `MyISAM` 被 `InnoDB` 取代的重要原因之一。

### 事务特性 ACID
- 原子性（`Atomicity`）
- 一致性（`Consistency`）
- 隔离性（`Isolation`）
- 持久性（`Durability`）

### 隔离级别

当数据库有多个事务同时执行的时候，就可能出现脏读（`dirty read`）、不可重复读（`non-repeatable read`）、幻读（`phantom read`），为了解决这些问题，就有了 `事务隔离` 的概念。

- 脏读：当数据库中一个 `事务A` 正在修改一个数据但是还未提交或者回滚，另一个 `事务B` 来读取了修改后的内容并且使用了，之后 `事务A` 提交了，此时就引起了脏读。此情况仅会发生在：读未提交的的隔离级别。
- 不可重复读：在一个 `事务A` 中多次操作数据，在事务操作过程中(未最终提交)，`事务B` 也才做了处理，并且该值发生了改变，这时候就会导致 `事务A` 在操作的时候，发现数据与第一次不一样了，就是不可重复读。此情况仅会发生在：读未提交、读提交的隔离级别。
- 幻读：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为幻读。
幻读是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入“一行新数据”。那么，以后就会发生操作第一个事务的用户发现表中还存在没有修改的数据行，就好象发生了幻觉一样。
一般解决幻读的方法是增加 `范围锁 RangeS`，锁定检索范围为只读，这样就避免了幻读。
此情况会回发生在：读未提交、读提交、可重复读的隔离级别。

SQL 标准的事务隔离级别包括：
- 读未提交（`read uncommitted`）：一个事务还没提交时，它做的变更就能被其它事务看到。
- 读提交（`read committed`）：一个事务提交之后，它做的变更才会被其它事务看到。
- 可重复读（`repeatable table`）：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的，未提交变更对其它事务也是不可见的。
- 串行化（`serializable`）：对于同一行记录，`写` 会加 `写锁`，`读` 会加 `读锁`。当出现读写冲突时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

隔离得越严实，效率就会越低。
四种情况并行性能依次降低，安全性依次提高。

`MySQL` 查看事务隔离级别命令： `show variables like 'transaction_isolation';`

### 事务隔离的实现

每条记录在更新的时候都会同时记录一条回滚操作。同一条记录在系统中可以存在多个版本，这就是数据库的多版本并发控制（`MVCC`）。

回滚日志什么时候删除？系统会判断当没有事务需要用到这些回滚日志的时候，回滚日志会被删除。

什么时候不需要了？当系统里没有比这个回滚日志更早的 `read-view` 的时候。

为什么尽量不要使用长事务？长事务意味着系统里面会存在很老的事务视图，在这个事务提交之前，回滚记录都要保留，这会导致大量占用存储空间。除此之外，长事务还占用锁资源，可能会拖垮库。

### 事务的启动方式

1. 显式启动事务语句， `begin` 或 `start transaction`。配套的提交语句是 `commit`，回滚语句是 `rollback`。

2. `set autocommit=0`，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个 `select` 语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行 `commit` 或 `rollback` 语句，或者断开连接。

有些客户端连接框架会默认连接成功后先执行一个 `set autocommit=0` 的命令。这就导致接下来的查询都在事务中，如果是长连接，就导致了意外的长事务。建议总是使用 `set autocommit=1`, 通过显式语句的方式来启动事务。

在 `autocommit` 为 `1` 的情况下，用 `begin` 显式启动的事务，如果执行 `commit` 则提交事务。如果执行 `commit work and chain`，则是提交事务并自动启动下一个事务，这样也省去了再次执行 `begin` 语句的开销。同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。


### 如何避免长事务
```
在 information_schema 库的 innodb_trx 这个表中查询长事务，比如下面这个语句，用于查找持续时间超过 60s 的事务。

select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60
```

在开发过程中，尽可能的减小事务范围，少用长事务，如果无法避免，保证逻辑日志空间足够用，并且支持动态日志空间增长。监控 `Innodb_trx` 表，发现长事务报警。
