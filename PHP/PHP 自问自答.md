### 1. MVC 介绍一下？
MVC 是一种框架模式。
框架和设计模式的区别：框架是大智慧，用来对软件设计进行分工；设计模式是小技巧，对具体问题提出解决方案，以提高代码复用率，降低耦合度。

- Model(模型) 是应用程序用于处理应用程序数据逻辑的部分。通常模型对象负责在数据库中存取数据。
- View(视图) 是应用程序中处理数据显示的部分。通常视图是依据模型数据创建的。
- Controller(控制器) 是应用程序中处理用户交互的部分。通常控制器负责从视图层读取数据，控制用户输入，并向模型发送数据。

### 2. 面向对象编程中的 23 种设计模式

- 创建型
  - 常用：
    - 单例模式
    - 工厂模式(工厂方法和抽象工厂)
    - 建造者模式
  - 不常用：
    - 原型模式

- 结构型
  - 常用：
    - 代理模式
    - 桥接模式
    - 装饰者模式
    - 适配器模式
  - 不常用：
    - 门面模式
    - 组合模式
    - 享元模式

- 行为型
  - 常用：
    - 观察者模式
    - 模板模式
    - 策略模式
    - 职责链模式
    - 迭代器模式
    - 状态模式
  - 不常用：
    - 访问者模式
    - 备忘录模式
    - 命令模式
    - 解释器模式
    - 中介模式


### 3. php对象的魔术方法和说明它们的用途

`PHP` 将所有以 `__（两个下划线）` 开头的类方法保留为魔术方法。
相对不错的介绍：https://segmentfault.com/a/1190000007250604

- `__construct()`:实例化对象时被调用
- `__destruct()`:当删除一个对象或对象操作终止时被执行
- `__call()`:调用对象不存在的方法时被调用
- `__callStatic()`:用静态方式中调用一个不可访问方法时被调用
- `__get()`:调用对象不存在的属性时被调用
- `__set()`:设置对象不存在的属性时被调用
- `__toString()`:打印一个对象时被调用，比如 `echo $obj,print($obj)`
- `__clone()`:克隆对象时被调用，比如 `$t = new Test();$tt = clone $t`
- `__sleep()`:`serialize` 之前被调用，若对象比较大，想做一些删除在序列化，可以考虑此方法
- `__wakeup()`:`unserialize` 之前被调用，做些对象的初始化
- `__isset()`:检测对象是否存在属性的时候被调用，如 `isset($c->name)`
- `__unset()`:`unset` 一个对象时被调用，如：`unset($c->name)`
- `__set_state()`:调用 `var_export` 时被调用，用 `__set_state` 的返回值作为 `var_export` 的返回值
- `__autoload()`:尝试加载未定义的类，(`PHP 7.2`以后被弃用)
- `__debugInfo()`:当调用 `var_dump()` 输出一个对象时，如果该对象定义了 `__debugInfo()` 魔术方法，那么就会自动先调用该魔术方法返回的结果，然后再输出，否则默认会输出对象的所有可见属性。
- `__invoke()`:当尝试以调用函数的方式调用一个对象时，`__invoke()` 方法会被调用。

### 4. abstract 和 interface 的共同点与区别
此文介绍
https://juejin.im/post/5b8f546fe51d450e4627ebbb

self 与 static 区别
self 只能引用当前类中的方法，而 static 关键字允许函数能够在运行时动态绑定类中的方法。

后期静态绑定

### 5. __autoload() 方法的工作原理是什么？

使用这个魔术函数的基本条件是类文件的文件名要和类的名字保持一致。

当程序执行到实例化某个类的时候，如果在实例化前没有引入这个类文件，那么就自动执行 `__autoload()` 函数。

这个函数会根据实例化的类的名称来查找这个类文件的路径，当判断这个类文件路径下确实存在这个类文件后，就执行 `include` 或者 `require` 来载入该类，然后程序继续执行，如果这个路径下不存在该文件时就提示错误。

使用自动载入的魔术函数可以不必要写很多个 `include` 或者 `require` 函数。

`include` 引入文件的时候，如果碰到错误，会给出提示，并继续运行下边的代码。

`require` 引入文件的时候，如果碰到错误，会给出提示，并停止运行下边的代码。

### 6. session 和 cookie 的联系和区别

#### 区别：

- 1.存放位置：Session保存在服务器，Cookie保存在客户端。

- 2.存放的形式：Session是以对象的形式保存在服务器，Cookie以字符串的形式保存在客户端。

- 3.用途：Cookies适合做保存用户的个人设置,爱好等,Session适合做客户的身份验证

- 4.路径：Session不能区分路径，同一个用户在访问一个网站期间，所有的Session在任何一个地方都可以访问到。而Cookie中如果设置了路径参数，那么同一个网站中不同路径下的Cookie互相是访问不到的。

- 5.安全性：Cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session

- 6.大小以及数量限制:每个域名所煲含的cookie 数:IE7/8,FireFox:50个, Opera30个； Cookie总大小：Firefox和Safari允许cookie多达4097个字节，Opera允许cookie多达4096个字 节，InternetExplorer允许cookie多达4095个字节；一般认为Session没有大小和数量限制。

#### 联系：

- 1.Session需要借助Cookie才能正常工作。如果客户端完全禁止Cookie，Session将失效！因为Session是由应用服务器维持的一个 服务器端的存储空间，用户在连接服务器时，会由服务器生成一个唯一的SessionID,用该SessionID 为标识符来存取服务器端的Session存储空间。而SessionID这一数据则是保存到客户端，用Cookie保存的，用户提交页面时，会将这一 SessionID 提交到服务器端，来存取Session数据。这一过程，是不用开发人员干预的。所以一旦客户端禁用Cookie，那么Session也会失效。

#### 如何修改SESSION的生存时间

- 1.设置浏览器保存的sessionid失效时间 setcookie(session_name(), session_id(), time() + $lifeTime, "/");

- 2.可以使用SESSION 自带的 session_set_cookie_params(86400); 来设置 Session 的生存期

- 3.通过修改php.ini中的session.gc_maxlifetime参数的值就可以改变session的生存时间
